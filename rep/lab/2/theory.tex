
\newcommand{\myip}{192.168.91.1}
\newcommand{\virtip}{192.168.91.128}

\subsubsection{Протоколы транспортного уровня стека протоколов TCP/IP}

	Протоколы транспортного уровня сетевой модели OSI предназначены для обеспечения передачи данных с нужными процессам,
	организующим сетевой обмен, показателями надежности, быстродействия и прочими характеристиками процесса обмена.

	К протоколам транспортного уровня стека протоколов TCP/IP относятся следующие протоколы:

	\begin{itemize}

		\item Transmission Control Protocol (TCP) - протокол, обеспечивающий гарантированную доставку данных с сохранением порядка
		отправления блоков данных за счет создания виртуального канала передачи данных;

		\item User Datagram Protocol (UDP) - протокол передачи дейтаграмм.
		
		Протокол UDP, в отличие от протокола TCP, не создает виртуальный канал передачи данных и поэтому не обеспечивает
		гарантированную доставку данных с сохранением порядка отправления блоков данных.
		Очевидное преимущество протокола UDP перед протоколом TCP состоит в том,
		что протокол UDP не генерирует дополнительный служебный трафик, обеспечивающий функционирование виртуального
		канала. Протокол UDP, таким образом, можно использовать в надежных сетях для передачи потока данных,
		чувствительного к задержкам (например, видеоданных или данных аудиовещания);

		\item Stream Control Transmission Protocol (SCTP) - протокол, обеспечивающий гарантированную доставку данных с сохранением порядка
		отправления блоков данных за счет создания виртуального канала передачи данных.
		
		В отличие от протокола TCP протокол SCTP не подвержен атакам типа SYN-флуд и поддерживает многопоточную передачу данных;

		\item Прочие протоколы.

	\end{itemize}

\subsubsection{Адресация сетевых узлов}

	На транспортном и сетевом уровнях стека протокола TCP/IP используется логическая схема адресации сетевых узлов называемая
	IP-адресацией. IP-адрес суть есть беззнаковое целое число, идентифицирующее сетевой узел
	в пределах некоторого сегмента вычислительной сети. В настоящее время широко используется IPv4-адресация,
	в соответствии с которой IP-адрес суть есть четырехбайтовое беззнаковое целое число. Все большую популярность
	набирает шестибайтовая IPv6-адресация. В данном курсе лабораторных работ используется IPv4-адресация сетевых узлов.

	При осуществлении сетевого обмена IP-адреса записываются в сетевом порядке байт в соответствующие поля пакетов используемых протоколов.
	Сетевой порядок байт суть есть порядок байт от старшего байта к младшему слева направо (порядок байт big-endian).
	В вычислительных системах целые числа представляются в порядке байт хоста, который может отличаться от сетевого порядка байт -
	так, например, в вычислительных системах, основанных на процессорах архитектур ia32 и ia64, порядок байт хоста суть есть
	порядок байт от младшего байта к старшему слева направо (порядок байт little-endian) - то есть порядок байт хоста обратен сетевому порядку байт.
	В \linux\ библиотека GLIBC предоставляет функционал для преобразования целых чисел из порядка байт big-endian в порядок байт little-endian и обратно.

	Существует несколько способов записи IPv4-адресов (в дальнейшем называемых просто IP-адресами):

	\begin{itemize}

		\item Стандартная (традиционная нотация) вида ЧИСЛО.ЧИСЛО.ЧИСЛО.ЧИСЛО, где ЧИСЛО - значение очередного байта адреса,
		записанное в десятичной системе счисления. Порядок записи значений байт IP-адреса определяется порядком байт хоста;

		\item Запись вида ЧИСЛО.ЧИСЛО.ЧИСЛО.ЧИСЛО/КОЛИЧЕСТВО\_БИТ, используемая в случае бесклассового метода адресации.
			Здесь ЧИСЛО - значение очередного байта адреса, записанное в десятичной системе счисления. Порядок записи значений байт IP-адреса определяется
			порядком байт хоста. КОЛИЧЕСТВО\_БИТ суть есть количество значащих бит в адресе, считая слева направо;

		\item Запись в шестнадцатеричной системе счисления;

		\item Другие формы записи.

	\end{itemize}

	IP-адресация обеспечивает гибкий механизм логической декомпозиции вычислительной сети в виде иерархической структуры подсетей.
	Каждая подсеть описывается адресом подсети и маской подсети и состоит из одного или нескольких сетевых узлов. IP-адрес сетевого узла, таким образом, можно
	представить в виде IP-адреса подсети и адреса (номера) сетевого узла в соответствующей подсети.

	Для разделения множества IP-адресов на адреса сетей, адреса сетевых узлов и служебные адреса используется один из возможных методов адресации:
	классовая адресация и бесклассовая адресация.
	
	Классовая адресация предполагает разделение множества возможных IP-адресов на адреса сетей трех классов (A, B и C),
	на класс адресов многоадресной рассылки (multicast; класс D), на класс зарезервированных адресов (E) и на адреса сетевых узлов.
	Практика показала, что классовая адресация не обладает достаточной степенью гибкости распределения IP-адресов и поэтому неудобна,
	вследствие чего классовую адресацию вытеснила бесклассовая адресация.

	Бесклассовая адресация (Classless InterDomain Routing; CIDR) не разделяет множество возможных IP-адресов на классы. Бесклассовая адресация
	предполагает существование сетей с произвольными IP-адресами, определяемыми по IP-адресам узлов, составляющих сети, с помощью масок сетей.
	Маска сети суть есть четырехбайтовое беззнаковое целое число.

	Различают следующие виды IP-адресов:

	\begin{itemize}

		\item Адрес сети.

			Адрес сети может быть получен из адреса сетевого узла, входящего в сеть, с помощью маски сети следующим образом: адрес сети равен
			(адрес сетевого узла AND маска сети).

			Допускается запись адреса сети в виде ЧИСЛО.ЧИСЛО.ЧИСЛО.ЧИ\-СЛО/КО\-ЛИ\-ЧЕ\-СТВО\_БИТ, где КОЛИЧЕСТВО\_БИТ суть есть количество единичных бит,
			считая слева направо, в маске сети;

		\item Адреса многоадресной рассылки (multicast) вида ЧИСЛО.ЧИСЛО.ЧИСЛО.ЧИ\-СЛО.

			Здесь крайний левый байт принимает значения из диапазона от 224 до 239 включительно (первые четыре бита крайнего левого байта данного адреса
			установлены в 1110);

		\item Простой (ограниченный) широковещательный адрес 255.255.255.255\\(simple broadcast; limited broadcast).

			Пакет, отправленный на простой широковещательный адрес, будет отослан всем узлам всех сетей. Пакеты, рассылаемые таким образом,
			очевидно, генерируют существенные объемы паразитного трафика и поэтому часто игнорируются маршрутизаторами;

		\item Направленный широковещательный адрес (direct broadcast).

			Пакет, отправленный на направленный широковещательный адрес, будет отослан только тем сетевым узлам,
			которые расположены в сети, к которой данный адрес относится.

			Широковещательный адрес может быть определен по адресу сети с помощью маски сети следующим образом: (адрес сети XOR (NOT маска сети)).

		\item Адрес сетевого узла вида ЧИСЛО.ЧИСЛО.ЧИСЛО.ЧИСЛО, где крайний левый байт не превосходит 224.

	\end{itemize}

	Следующие блоки IP-адресов зарезервированы для сетей специальных видов:

	\begin{itemize}
		
		\item 0.0.0.0/8	- блок адресов, указывающих на сетевые узлы в данной сети. Так, например, IP-адрес 0.0.0.0/32 указывает на сетевой узел,
		с которого произошло обращение по данному адресу;

		\item 127.0.0.0/8 - блок адресов, зарезервированных для обратной петли (loopback; сетевой интерфейс lo в \linux).

			Обратная петля всегда указывает на ту вычислительную систему, которой управляет оператор;

		\item Приватные сети:

			\begin{itemize}

				\item 10.0.0.0/8;
				\item 172.16.0.0/12;
				\item 192.168.0.0/16;

			\end{itemize}

			Приватные сети, как правило, используются для организации локальных вычислительных сетей;

		\item 14.0.0.0/8 - зарезервирован для сетей передачи данных общественного пользования;
		\item 169.254.0.0/16 - блок адресов, используемых в протоколах автоконфигурации;
		\item 192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24 - блоки тестовых адресов, используемых в документации и примерах кода;
		\item 192.88.99.0/24 - блок для использования в качестве альтернативных адресов для 6to4\footnote{6to4 - механизм передачи IPv6-пакетов в
		вычислительных сетях, использующих стек протоколов TCP/IPv4.};
		\item 198.18.0.0/15	- блок для использования в аттестационных испытаниях сетевых устройств;

		\item Зарезервированы для будущего использования:

			\begin{itemize}

				\item 39.0.0.0/8;
				\item 128.0.0.0/16;
				\item 191.255.0.0/16;
				\item 192.0.0.0/24;
				\item 223.255.255.0/24;
				\item 240.0.0.0/4 (кроме 255.255.255.255).

			\end{itemize}

	\end{itemize}

\subsubsection{Виртуальные TCP-порты и UDP-порты сетевых интерфейсов}

	Одним из ключевых понятий, рассматриваемых при использовании протоколов UDP и TCP, является понятие <<порт>>.
	Порт суть есть некоторый виртуальный <<слот>> сетевого интерфейса, который может быть занят некоторым процессом.
	Процесс может прослушивать порт в ожидании поступления данных в порт и читать поступившие данные из порта.
	Процесс так же может записывать данные в порт для передачи их на некоторый, прослушиваемый процессом - получателем
	данных, порт сетевого интерфейса удаленного сетевого узла.

	Различают TCP-порты и UDP-порты сетевого интерфейса. Каждый порт протоколов имеет уникальный номер
	в диапазоне от 1 до 65535 - таким образом, сетевой интерфейс располагает ($2^{16} - 1$) TCP-портами и таким же
	количеством UDP-портов. Порты с диапазоном номеров от 1 до 1024-х считаются привилегированными
	и недоступны для использования процессам, не имеющим характеристики CAP\_NET\_BIND\_SERVICE\footnote{Процессам,
	имеющим эффективным владельцем суперпользователя, данная характеристика присваивается автоматически.},
	прочие порты доступны для использования всеми процессами системы.

	Принципиальное отличие использования TCP-портов от UDP-портов заключается в том, что взаимодействующие
	по протоколу TCP процессы блокируют пару используемых портов (по одному на каждом из используемых сетевых
	интерфейсов), организуя с их помощью виртуальный канал. UDP-порты не блокируются и могут быть использованы
	параллельно несколькими процессами вычислительной системы. Необходимо также отметить, что специфика создания
	виртуального канала протокола TCP требует, чтобы один из процессов, использующих канал, предварительно был запущен
	в режиме прослушивания одного из TCP-портов сетевого интерфейса - таковой процесс называется процессом - сервером.
	Процесс - клиент подключается к порту, занятому процессом сервером, и, если процесс - сервер
	принимает предложение процесса - клиента установить соединение, процесс - сервер занимает отдельный TCP-порт
	своего сетевого интерфейса, который и используется как один из портов, обеспечивающих функционирование
	виртуального канала (другим таковым портом является занятый процессом - клиентом TCP-порт соответствующего
	сетевого интерфейса).

\subsubsection{Сокеты как основное средство системного программирования в \linux}

	Сетевое программирование в \linux\ построено на концепции <<сокет>>. Сокет суть есть оконечная точка
	сетевой коммуникации, абстрагируемая в виде файла. Пользовательская программа может работать с сокетом
	с помощью средств файлового ввода / вывода, предоставляемых ОС, однако данные средства могут оказаться неудобными для
	работы с сокетами, и поэтому для осуществления сетевого взаимодействия в большинстве случаев используется
	функционал, схожий с функционалом ОС, предназначенным для организации файлового ввода/вывода,
	но все же несколько отличный от него.

\subsubsection{Утилиты netstat и ncat. Файлы /etc/services и /etc/hosts}

	Для получения информации об использовании процессами ОС портов различных протоколов сетевых интерфейсов вычислительной
	системы оператор может воспользоваться утилитой netstat. Для осуществления обмена данными между операторами двух удаленных друг
	от друга вычислительных систем означенные операторы могут использовать утилиту ncat, входящую в состав программного комплекса
	nmap\footnote{Программный комплекс nmap является популярнейшим свободным сетевым сканером. В состав nmap,
	кроме непосредственно сканера, входят также утилиты ncat, nping и ndiff.}.

	Для определения прослушиваемых процессами ОС портов протокола UDP сетевых интерфейсов вычислительной системы можно воспользоваться утилитой netstat,
	запустив ее с ключами <<-u>>, <<-l>> и, опционально, <<-n>> и <<-p>>. Данные ключи имеют следующий смысл:

	\begin{itemize}

		\item <<-u>> - предписывает утилите netstat вывести информацию о портах протокола UDP.

		Для предписания утилите netstat вывести информацию о портах протокола TCP утилите необходимо передать ключ <<-t>> вместо ключа <<-u>>;

		\item <<-l>> - предписывает утилите netstat вывести информацию о прослушиваемых портах протокола UDP - то есть о портах,
		которые заняты процессами, ожидающими получение данных, но не участвующими в момент запуска утилиты netstat в получении / передаче данных;

		\item <<-n>> - предписывает утилите netstat вывести информацию о портах и сетевых адресах в численном представлении, иначе, в некоторых случаях,
		информация может быть выведена в символьной форме (например, IP-адрес сетевого узла может быть заменен на его символьный адрес) или вообще подавлена;
		
		\item <<-p>> - предписывает утилите netstat вывести информацию о процессах операционной системы, использующих UDP-порты.

	\end{itemize}

	На рисунке \ref{image:lab2-2} приведен вывод утилиты netstat, запущенной с ключами <<-u>>, <<-l>>, <<-n>> и <<-p>>.
	Можно увидеть, что в момент получения утилитой netstat данных об используемых портах протокола UDP сетевых интерфейсов системы, открытыми являются
	следующие UDP-порты:

	\begin{itemize}

		\item Порт 7777 на всех сетевых интерфейсах системы - используется утилитой ncat;

		\item Порт 8888 на сетевом интерфейсе с IP-адресом, равным 127.0.0.1 (обратная петля; lo) - используется интерпретатором языка программирования
		Python 3.

	\end{itemize}

	\mimage{lab2-2}{2/2}{Результаты выполнения утилиты netstat, запущенной с ключами <<-u>>, <<-l>>, <<-n>> и <<-p>>}{width=\textwidth}

	Рассмотрим использование утилиты ncat для обмена данными между операторами двух удаленных друг от друга вычислительных систем с использованием протокола UDP.

	На рисунке \ref{image:lab2-4} приведен процесс запуска утилиты ncat в режиме сервера (в режиме ожидания поступления данных) на сетевом узле \myip.
	На рисунке \ref{image:lab2-5} приведен процесс отправки клиентом целевому серверу содержимого файла Makefile с помощью утилиты ncat.
	На рисунке \ref{image:lab2-7} приведены данные, полученные утилитой ncat, запущенной в режиме сервера на сетевом узле \myip.
	Можно увидеть, что пересылка данных прошла успешно и принятые сервером данные совпадают с содержимым файла Makefile, расположенного на клиентской стороне.
	Для останова сервера, организованного с помощью утилиты ncat, утилите ncat был послан сигнал SIGINT нажатием сочетания клавиш <<Ctrl + C>> в том терминале
	сетевого узла \myip, в котором сервер был запущен.

	Для выполнения перечисленных действий утилите ncat были переданы следующие ключи:

	\begin{itemize}

		\item <<-u>> - предписывает утилите ncat использовать протокол UDP для обмена данными.

		Для предписания утилите ncat использовать протокол TCP для обмена данными необходимо запустить утилиту ncat без ключа <<-u>>;

		\item <<-l>> - предписывает утилите ncat ожидать поступления информации (то есть работать в режиме сервера) (только для сервера);
		\item <<-p PORT>> - предписывает утилите ncat использовать указанный UDP-порт (только для сервера);
		\item <<--send-only>> - предписывает утилите ncat завершить свое выполнение после того, как в стандартном потоке ввода будет достигнут признак конца
		файла (EOF) (только для клиента);
		\item IP адрес целевого сервера и номер целевого UDP-порта (только для клиента).

	\end{itemize}

	На рисунке \ref{image:lab2-5} средствами командной оболочки стандартный поток ввода утилиты ncat был направлен на файл Makefile
	с помощью конструкции <<< Makefile>>.

	\mimage{lab2-4}{2/4}{Запуск утилиты ncat в режиме сервера на сетевом узле \myip}{}
	\mimage{lab2-5}{2/5}{Отправка целевому серверу содержимого файла Makefile}{width=\textwidth}
	\mimage{lab2-7}{2/7}{Данные, полученные сервером, запущенном на сетевом узле \myip}{width=\textwidth}

	Обмен файлами между клиентом и сервером выполняется аналогично обмену данными, вводимыми с клавиатуры, с той лишь разницей,
	что отправляемые данные клиент и сервер должны считывать из файлов, а получаемые данные - сохранять в файлах, а не только выводить в стандартный поток
	вывода.

	На рисунке \ref{image:lab2-101} приведен процесс запуска в режиме сервера и результаты выполнения утилиты ncat на сетевом узле \myip.
	На рисунке \ref{image:lab2-102} приведен процесс запуска в режиме клиента (с отправлением данных на UDP-порт 7777 сетевого узла \myip)
	и результаты выполнения утилиты ncat на сетевом узле \virtip.

	Для сохранения получаемых утилитой ncat данных в файлы в каждом из случаев было использовано перенаправление
	стандартных потоков вывода в соответствующие файлы, выполненное средствами командного интерпретатора.
	На рисунках \ref{image:lab2-101} и \ref{image:lab2-102} приведены контрольные суммы (MD5-хэши) передаваемых и получаемых файлов,
	вычисленные на сторонах сервера и клиента соответственно - контрольные суммы совпадают
	и, таким образом, можно сделать вывод, что с высокой вероятностью (с точностью до коллизии) передача файлов прошла успешно.

	\mimage{lab2-101}{2/101}{Результаты выполнения утилиты ncat, запущенной в режиме сервера на сетевом узле \myip}{width=\textwidth}
	\mimage{lab2-102}{2/102}{Результаты выполнения утилиты ncat, запущенной в режиме клиента на сетевом узле \virtip}{width=\textwidth}

	Утилиту ncat можно использовать, кроме всего прочего, для рассылки широковещательных дейтаграмм протокола UDP.
	На рисунке \ref{image:lab2-17} приведен вывод команды ifconfig, содержащий информацию о настройках сетевого интерфейса tap0.
	На рисунке \ref{image:lab2-17} видно, что широковещательный адрес в сети, к которой принадлежат сетевые узлы \myip\ и \virtip, суть есть 192.168.91.255.

	На рисунке \ref{image:lab2-20} приведен процесс выполнения утилиты ncat на сетевом узле \linebreak \myip,
	состоящий в отправке строки символов <<test broadcast>> на широковещательный адрес 192.168.91.255 на UDP-порт 7777.
	На рисунке \ref{image:lab2-21} приведены результаты выполнения утилиты ncat, запущенной в режиме сервера на UPD-порту 7777 сетевого узла \virtip.
	На рисунках \ref{image:lab2-20} и \ref{image:lab2-21} можно увидеть, что переданная и принятая строки совпадают -
	таким образом, можно сделат вывод, что broadcast вещание в сети, связывающей узлы \myip\ и \virtip, произведено успешно.

	\mimage{lab2-17}{2/17}{Получение broadcast-адреса сети, связывающей сетевые узлы \myip\ и \virtip, с помощью утилиты ifconfig}{width=\textwidth}
	\mimage{lab2-20}{2/20}{Отправление тестового сообщения на широковещательный адрес 192.168.91.255 сетевым узлом \myip}{width=\textwidth}
	\mimage{lab2-21}{2/21}{Прием тестовой строки на сетевом узле \virtip}{width=\textwidth}

	На рисунке \ref{image:lab2-22} приведен процесс выполнения утилиты ncat на сетевом узле \myip,
	состоящий в отправке строки символов <<test broadcast 255.255.255.255>> на широковещательный адрес 255.255.255.255 на UDP-порт 7777.
	На рисунке \ref{image:lab2-23} приведены результаты выполнения утилиты ncat, запущенной в режиме сервера на UPD-порту 7777 сетевого узла \virtip.
	На рисунках \ref{image:lab2-22} и \ref{image:lab2-23} можно увидеть, что переданная и принятая строки совпадают - таким образом, можно сделать вывод, что
	broadcast вещание на адрес \linebreak 255.255.255.255 произведено успешно.

	\mimage{lab2-22}{2/22}{Отправление тестовой строки на широковещательный адрес 255.255.255.255 сетевым узлом \myip}{width=\textwidth}
	\mimage{lab2-23}{2/23}{Прием тестовой строки сетевым узлом \virtip}{width=\textwidth}

	Организация IANA (Internet Assigned Numbers Authority) поддерживает список портов, традиционно закрепленных
	за определенными сетевыми службами (например, TCP-порты 20 и 21 традиционно используются FTP-серверами). Каждому
	таковому порту для удобства доступа к нему может быть присвоен некоторый символьный псевдоним.
	\linux\ поддерживает присвоение символьных псевдонимов портам определенных протоколов с определенными номерами.
	Означенные псевдонимы перечислены в файле /etc/services и действуют только для данной вычислительной системы.
	Добавление псевдонима порту определенного протокола с определенным номером заключается в добавлении
	соответствующей записи в означенный файл.

	На рисунке \ref{image:lab2-9} приведен процесс добавления в файл /etc/services записи о UDP-порте 7777 (право редактировать файл /etc/services имеет только
	суперпользователь). На рисунке \ref{image:lab2-10} приведен процесс запуска утилиты ncat
	в режиме сервера на UDP-порте 7777. На рисунке \ref{image:lab2-14} приведен вывод утилиты netstat, запущенной без ключа <<-n>>
	(таким образом, трансляция символьных представлений адресов и портов в их числовые представления утилитой netstat не выполнялась).
	На рисунке \ref{image:lab2-14} можно увидеть, что порт 7777, на котором запущена утилита ncat, имеет символьное имя <<net-lab>>.

	\mimage{lab2-9}{2/9}{Добавление в файл /etc/services записи о UDP-порте 7777}{width=\textwidth}
	\mimage{lab2-10}{2/10}{Запуск утилиты ncat в режиме сервера на UDP-порте 7777}{width=\textwidth}
	\mimage{lab2-14}{2/14}{Вывод утилиты netstat}{width=\textwidth}

	Очевидно, что использование в процессе сетевого обмена с помощью протоколов стека протоколов TCP/IP IP-адресов, состоящих из обезличенного набора чисел,
	не удобно с практической точки зрения. Точно так же, как и портам, IP-адресам можно присваивать символьные псевдонимы (символьные адреса).
	Широкоприменяемым способом трансляции символьных имен в соответствующие IP-адреса является использование DNS-серверов, что будем именовать
	динамической трансляцией. Статической трансляцией можно считать сопоставление символьным именам IP-адресов с помощью файла /etc/hosts.

	На рисунке \ref{image:lab2-1-15} приведено содержимое файла /etc/hosts некоторой вычислительной системы.
	Как видно из рисунка, в данной вычислительной системе используются три символьных имени для обратной петли:

	\begin{itemize}

		\item localhost.localdomain;
		\item localhost;
		\item amv.

	\end{itemize}

	На рисунке \ref{image:lab2-1-14} приведены результаты выполнения команды ping к обратной петле с использованием одного из ее символьных имен
	(<<localhost>>).

	\mimage{lab2-1-15}{2/1-15}{Содержимое файла /etc/hosts}{width=\textwidth}
	\mimage{lab2-1-14}{2/1-14}{Команда ping к localhost (127.0.0.1)}{width=\textwidth}

	Одним из способов создания символьных псевдонимов для целевых IP-адресов является, очевидно, редактирование файла /etc/hosts.
	Этот способ работает только в той вычислительной системе, файл /etc/hosts которой был отредактирован.
	Для редактирования файла /etc/hosts необходимы права суперпользователя.

	На рисунке \ref{image:lab2-1-20} приведен процесс редактирования файла /etc/hosts суперпользователем. При этом обратной петле назначается дополнительное
	символьное имя <<lab-loopback>>, а узлу \virtip~- символьное имя <<lab-virtual>>. На рисунках \ref{image:lab2-1-17} и \ref{image:lab2-1-18} приведены
	результаты выполнения команды ping к узлам lap-loopback и lab-virtual соответственно. На рисунках \ref{image:lab2-1-17} и \ref{image:lab2-1-18}
	хорошо видно, что утилита ping, используя информацию из файла /etc/hosts, корректно преобразовала символьные имена целевых узлов сети в
	соответствующие им IP-адреса.

	\mimage{lab2-1-20}{2/1-20}{Редактирование файла /etc/hosts}{width=\textwidth}
	\mimage{lab2-1-17}{2/1-17}{Команда ping к lab-loopback (127.0.0.1)}{width=\textwidth}
	\mimage{lab2-1-18}{2/1-18}{Команда ping к lab-virtual (\virtip)}{width=\textwidth}

\subsubsection{Протокол UDP}

	User Datagram Protocol (UDP) - протокол, не обеспечивающий гарантированную доставку данных с сохранением порядка отправления блоков данных.
	Передача данных по протоколу UDP осуществляется	с помощью дейтаграмм, вследствие чего снижается общий объем пересылаемого трафика
	в надежных сетях по сравнению с протоколом TCP, так как виртуальный канал, создаваемый протоколом TCP,
	обеспечивается пересылкой различного рода служебных пакетов.

	Структура пакета протокола UDP приведена на рисунке \ref{image:lab2-udp-struct}.

	\vbox
	{
		\begin{center}
			
			\refstepcounter{figure}
			\label{image:lab2-udp-struct}

			\begin{bytefield}{32}
				\bitheader{0,31}\\
				\begin{rightwordgroup}{Заголовок пакета}
				\bitbox{32}{Source port}\\
				\bitbox{32}{Destination port}\\
				\bitbox{32}{Length}\\
				\bitbox{32}{Checksum}
				\end{rightwordgroup}\\
				\wordbox{1}{Data}
			\end{bytefield}

			{\noindent Рисунок~\thefigure~---~Структура пакета протокола UDP}

		\end{center}
	}

	Заголовок пакета протокола UDP состоит из следующих полей:

	\begin{itemize}
		
		\item <<Source port>> - UDP-порт соответствующего сетевого интерфейса, через который процесс - отправитель посылает дейтаграмму;
		\item <<Destination port>> - UDP-порт назначения соответствующего сетевого интерфейса удаленного сетевого узла. Процесс - получатель прослушивает
		данный порт в ожидании получения дейтаграммы;
		\item <<Length>> - длина UDP-пакета в байтах;
		\item <<Checksum>> - контрольная сумма пакета.

	\end{itemize}

	Поле <<Data>> содержит информацию, передаваемую процессом - отправителем UDP-пакета процессу - получателю UDP-пакета.

	В программах на языке программирования C в \linux\ для работы с протоколом UDP удобно использовать UDP-сокеты.
	Процесс обмена с использованием UDP-протокола в программах на языке C в \linux\ выглядит следующим образом:

	\begin{enumerate}

		\item Создание сокета.

			Для создания сокета необходимо использовать системный вызов socket, принимающий следующие параметры:

			\begin{enumerate}

				\item Идентификатор семейства протоколов, один из протоколов которого используется.

					Возможные значения идентификатора семейства протоколов:

					\begin{itemize}

						\item AF\_INET - стек протоколов TCP/IPv4;
						\item AF\_INET6 - стек протоколов TCP/IPv6;
						\item AF\_UNIX и AF\_LOCAL - протокол межпроцессной коммуникации между процессами одной операционной системы;
						\item AF\_NETLINK - протокол межпроцессной коммуникации между процессами пользовательского пространства
						и процессами пространства ядра одной операционной системы;
						\item AF\_IPX - Novell'овские протоколы;
						\item AF\_PACKET - протоколы канального уровня сетевой модели OSI и некоторые протоколы сетевых уровней различных семейств протоколов;
						\item AF\_X25, AF\_AX25, AF\_ATMPVC и AF\_APPLETALK.

					\end{itemize}

					Для использования протокола UDP системному вызову socket необходимо передать первым параметром значение константы AF\_INET или AF\_INET6.
					Необходимо помнить, что в данной лабораторной работе используется IPv4 версия протокола IP;

				\item Идентификатор режима передачи пакетов.
				
					Возможные значения идентификатора режима передачи пакетов:

					\begin{itemize}

						\item SOCK\_STREAM - режим с организацией виртуального канала;
						\item SOCK\_DGRAM - режим с использованием дейтаграмм;
						\item SOCK\_RAW - <<сырые>> сокеты. Программа получает доступ к заголовку пакета (то есть самостоятельно формирует заголовок
						при отправлении пакетов и получает заголовок в результирующем буфере при получении пакетов) и, следовательно, должна
						самостоятельно организовывать соответствующий режим передачи пакетов;
						\item SOCK\_RDM, SOCK\_SEQPACKET - вариации режима с использованием дейтаграмм;
						\item SOCK\_PACKET - не рекомендующийся к использованию синоним\\AF\_PACKET.

					\end{itemize}

					Для использования протокола UDP системному вызову socket необходимо передать вторым параметром значение константы SOCK\_DGRAM;

				\item Идентификатор протокола сетевого взаимодействия, сокет для использования которого создается.
				
					Данный идентификатор может быть получен следующими способами:

					\begin{itemize}

						\item С помощью безымянного объединения (enum), описанного в заголовочном файле <linux/in.h>;
						\item С помощью файла /etc/protocols;
						\item С помощью функции getprotobyname() библиотеки GLIBC\footnote{Функция getprotobyname() оперирует, в конечном счете,
						файлом /etc/protocols.}.

					\end{itemize}

					В данной лабораторной работе для использования протокола UDP в качестве третьего параметра системному вызову socket необходимо передать
					значение \linebreak IPPROTO\_UDP безымянного объединения, описанного в заголовочном файле \linebreak <linux/in.h>.

			\end{enumerate}

			Таким образом, для создания UDP-сокета процесс должен выполнить системный вызов socket с параметрам AF\_INET, SOCK\_DGRAM и IPPROTO\_UDP.

			В случае успешного создания сокета системный вызов socket вернет номер дескриптора созданного сокета в таблице файловых
			дескрипторов процесса, в противном случае системный вызов socket вернет -1.

			Библиотека GLIBC предоставляет обертку для данного системного вызова, для использования которой необходимо включить в файл исходного кода программы
			заголовочные файлы <sys/types.h> и <sys/socket.h>;

		\item Привязка сокета к порту, который в дальнейшем будет прослушиваться процессом (выполняется только серверным приложением).

			Привязка сокета к порту осуществляется с помощью системного вызова bind, имеющего следующие параметры:

				\begin{enumerate}

					\item Номер дескриптора сокета в таблице файловых дескрипторов процесса;
					\item Адрес целевого сетевого интерфейса и номер занимаемого порта целевого сетевого интерфейса.

						Данный параметр суть есть указатель на экземпляр структуры данных sockaddr.
						В случае использования IPv4-адресации сетевых узлов в качестве указателя на экземпляр
						структуры данных sockaddr системному вызову bind передается указатель на экземпляр структуры данных sockaddr\_in.
						Указатель на экземпляр структуры данных sockaddr\_in явно приводится к указателю на экземпляр структуры данных sockaddr.

						Указываемый сетевой адрес суть есть IPv4-адрес сетевого интерфейса, указанный порт на котором будет прослушиваться процессом.
						В случае, если необходимо занять один и тот же порт на всех
						сетевых интерфейсах вычислительной системы, в качестве адреса целевого сетевого интерфейса указывается 0;

					\item Размер в байтах описателя адреса целевого сетевого интерфейса.

					В данном случае в качестве значения данного параметра передается\\sizeof(struct sockaddr\_in).

				\end{enumerate}

			Системный вызов bind возвращает 0 в случае успешной привязки сокета к порту и -1 в случае неудачного завершения означенной операции.

			Библиотека GLIBC предоставляет обертку для данного системного вызова, для использования которой необходимо включить в файл исходного кода программы
			заголовочные файлы <sys/types.h> и <sys/socket.h>;

		\item Запись данных в сокет (отправление данных процессу удаленного сетевого узла).

			Для отправления данных по протоколу UDP процессу удаленного сетевого узла удобно пользоваться системным вызовом sendto, принимающим следующие
			параметры:

			\begin{enumerate}

				\item Номер дескриптора сокета в таблице файловых дескрипторов процесса;
				\item Указатель на буфер, в который помещено содержимое поля <<Data>> отправляемого пакета;
				\item Размер в байтах поля <<Data>> отправляемого пакета (не превышает размер буфера);
				\item Флаги.

					В качестве флагов процесс может передать, кроме всего прочего, флаг \linebreak MSG\_DONTWAIT, как предписание ОС выполнить неблокирующуюся
					операцию. Неблокирующаяся операция не прерывает выполнение процесса и возвращает управление сразу же, как только запрос на ее выполнение
					будет совершен процессом. Неблокирующаяся операция успешно завершается только в том случае, если ОС может выполнить ее немедленно, если же
					для выполнения операции требуется некоторое ожидание (блокировка), то операция завершается неудачно\footnote{Код ошибки - EWOULDBLOCK,
					сохраняемый в переменной errno, определенной в заголовочном файле <errno.h>.}.

					В том случае, если в качестве флагов передан 0, то выполняется блокирующаяся операция -
					то есть операция, могущая заблокировать выполнение процесса в том случае, если для ее выполнения требуется некоторое ожидание;
					
				\item Адрес целевого сетевого узла.

				Данный параметр суть есть указатель на экземпляр структуры данных sockaddr. В случае использования
				IPv4-адресации сетевых узлов в качестве указателя на экземпляр структуры данных sockaddr передается
				указатель на экземпляр структуры данных sockaddr\_in. Указатель на экземпляр структуры данных
				sockaddr\_in явно приводится к указателю на экземпляр структуры данных sockaddr.

				Структура данных sockaddr\_in состоит из следующих полей:

				\begin{itemize}

					\item sin\_family - идентификатор используемого семейства протоколов (должно быть установлено в AF\_INET);

					\item sin\_port - номер порта целевого сетевого интерфейса узла сети, на который отправляется пакет.

						Номер порта записывается в сетевом порядке байт.

						Для приведения номера порта к сетевому порядку байт необходимо воспользоваться функцией htons() библиотеки GLIBC, определенной в
						заголовочном файле <arpa/inet.h>, принимающей единственным параметром 16-ти битовое целое беззнаковое число - номер порта
						в порядке байт хоста, и возвращающей 16-ти битовое целое беззнаковое число - номер порта в сетевом порядке байт;

					\item sin\_addr - IPv4-адрес целевого узла сети, записанный в сетевом порядке байт.

						Для преобразования IPv4-адреса, записанного в стандартной нотации (число.число.число.число) и сохраненного в строке,
						в соответствие этого адреса, записанное в беззнаковом целом с использованием сетевого порядка байт, используется функция inet\_addr()
						библиотеки GLIBC. Для использование означенной функции в программе в файл исходного кода программы необходимо включить заголовочные
						файлы <sys/socket.h>, <netinet/in.h> и <arpa/inet.h>. Функция inet\_addr() принимает единственным параметром строку с IPv4-адресом
						целевого узла сети и возвращает значение типа in\_addr\_t. Значение in\_addr\_t должно быть записано в поле\\sin\_addr.s\_addr;

				\end{itemize}

				\item Размер в байтах описателя адреса целевого сетевого узла.

					В данном случае в качестве значения данного параметра передается\\sizeof(struct sockaddr\_in).

			\end{enumerate}

			Системный вызов sendto возвращает количество отправленных байт из буфера buf (значение типа ssize\_t, что соответствует целому знаковому числу)
			в случае своего успешного выполнения и -1 в случае неудачи.

			Библиотека GLIBC предоставляет обертку для данного системного вызова, для использования которой необходимо включить в файл исходного кода программы
			заголовочные файлы <sys/types.h> и <sys/socket.h>;

		\item Чтение данных из сокета (получение данных от процесса удаленного сетевого узла).

			Для получения данных от процесса удаленного сетевого узла в случае протоколов TCP и UDP удобно пользоваться системным вызовом recv,
			принимающим следующие параметры:

			\begin{enumerate}

				\item Номер дескриптора сокета в таблице файловых дескрипторов процесса;
				\item Указатель на буфер, в который будет помещено содержимое поля <<Data>> принимаемого пакета;
				\item Максимально допустимый размер в байтах поля <<Data>> принимаемого пакета (не превышает размер буфера);
				\item Флаги.
					
					Как и в случае системного вызова sendto, операция чтения данных из сокета может быть выполнена в неблокируемом режиме.

			\end{enumerate}

			В случае протокола UDP процессу - получателю может потребоваться определить IP-адрес удаленного сетевого узла, на котором запущен
			процесс - отправитель, и номер порта соответствующего сетевого интерфейса, с которого процесс - отправитель отправил полученную дейтаграмму.
			Для одновременных считывания содержимого поля <<Data>> полученного пакета и определения IP-адреса удаленного сетевого узла и соответствующего
			номера порта соответствующего сетевого интерфейса удаленного сетевого узла процесс может воспользоваться системным вызовом recvfrom.
			Системный вызов recvfrom принимает те же параметры, что и системный вызов recv, а также два дополнительных параметра:

			\begin{enumerate}

				\item Указатель на экземпляр структуры данных sockaddr\_in, в который будет помещен
				IP-адрес удаленного сетевого узла и номер порта соответствующего сетевого интерфейса,
				с которого процесс - отправитель отправил дейтаграмму.

					Необходимо помнить, что IP-адрес и номер порта в экземпляре структуры данных sockaddr\_in
					хранятся в сетевом порядке байт.

					Для получения представления IP-адреса в стандартной нотации в виде текстовой строки можно
					воспользоваться функцией inet\_ntoa() библиотеки GLIBC, единственным параметром в которую
					необходимо передать значение поля sin\_addr экземпляра структуры данных sockaddr\_in.
					Функция inet\_ntoa() возвращает указатель на строку, содержащую представление IP-адреса
					в стандартной нотации. Для использования функции inet\_ntoa() в файл исходного кода программы
					необходимо включить заголовочные файлы <sys/socket.h> и <netinet/in.h>.

					Для преобразования номера порта из сетевого порядка байт в порядок байт хоста можно воспользоваться
					функцией ntohs() библиотеки GLIBC, единственным параметром в которую необходимо передать номер
					порта, записанный в сетевом порядке байт. Функция ntohs() возвращает номер порта, записанный
					в порядке байт хоста. Для использования функции ntohs() в файл исходного кода программы необходимо
					включить заголовочный файл <arpa/inet.h>;

				\item Указатель на целочисленную переменную типа socklen\_t, в которой будет сохранен размер
				в байтах экземпляра структуры данных sockaddr\_in.

			\end{enumerate}

			Системные вызовы recv и recvfrom возвращают количество полученных байт (значение типа ssize\_t,
			что соответствует целому знаковому числу) в случае своего успешного выполнения и -1 в случае неудачи.

			Библиотека GLIBC предоставляет обертки для данных системных вызовов, для использования которых
			необходимо включить в файл исходного кода программы заголовочные файлы <sys/types.h> и <sys/socket.h>;

		\item Уничтожение сокета.

			Для уничтожения сокета процесс должен воспользоваться системным вызовом close, принимающим единственным параметром номер дескриптора
			сокета в таблице файловых дескрипторов процесса.
			
			Библиотека GLIBC предоставляет обертку для данного системного вызова, для использования которой необходимо включить в файл исходного кода программы
			заголовочный файл <unistd.h>.

	\end{enumerate}

\subsubsection{Протокол TCP}

	Transmission Control Protocol (TCP) - протокол, обеспечивающий гарантированную доставку данных с сохранением порядка отправления блоков данных
	за счет создания виртуального канала передачи данных.

	Виртуальный канал суть есть механизм передачи данных, позволяющий двум взаимодействующим друг с другом процессам обмениваться данными
	с гарантированным совпадением порядка отправления блоков данных порядку их приема без риска потери данных при пересылке.
	Обмен данными по протоколу TCP между взаимодействующими друг с другом процессами состоит из следующих этапов:

	\begin{enumerate}

		\item Процесс - сервер занимает некоторый TCP-порт своего сетевого интерфейса и начинает прослушивать данный порт в ожидании поступления запроса
		на установ соединения от процесса - клиента;

		\item Процесс - клиент занимает TCP-порт своего сетевого интерфейса и отправляет через данный порт процессу - серверу запрос на установ соединения;

		\item Процесс - сервер принимает решение: возможен ли установ соединения? Если процесс - сервер решил установить соединение,
		то он занимает отдельный TCP-порт своего сетевого интерфейса и начинает обмен данными с процессом - клиентом;

		\item Процесс - клиент в случае, если процесс - сервер подтвердил установ соединения, начинает обмен данными с процессом - сервером;

		\item По завершению обмена процесс - сервер и процесс - клиент освобождают порты, занятые ими для обмена данными, после чего данные порты некоторое
		время, в зависимости от настроек операционных систем, не занимаются другими процессами;

		\item Процесс - сервер по своему завершению освобождает прослушиваемый порт, который также не выделяется ОС некоторое время другим процесса.

	\end{enumerate}

	На программном уровне обмен между процессами по протоколу TCP организуется с помощью TCP-сокетов.

	Процесс - сервер работает по следующему алгоритму:

	\begin{enumerate}

		\item Создание сокета.

			Для создания сокета необходимо использовать системный вызов socket, описанный ранее при рассмотрении протокола UDP, и принимающий,
			в случае протокола TCP, следующие значения параметров:

				\begin{enumerate}

					\item Идентификатор семейства протоколов - AF\_INET, что соответствует стеку протоколов TCP/IPv4;
					\item Идентификатор режима передачи пакетов - SOCK\_STREAM, что соответствует передаче пакетов через виртуальный канал;
					\item Идентификатор протокола сетевого взаимодействия - IPPROTO\_TCP, описанный в заголовочном файле <linux/in.h>;

				\end{enumerate}

		\item Привязка сокета к порту, который в дальнейшем будет прослушиваться процессом.

			Привязка сокета к порту осуществляется с помощью системного вызова bind, имеющего следующие параметры:

				\begin{enumerate}

					\item Номер дескриптора сокета в таблице файловых дескрипторов процесса;
					\item Адрес целевого сетевого интерфейса и номер занимаемого порта целевого сетевого интерфейса.

						Данный параметр суть есть указатель на экземпляр структуры данных sockaddr.
						В случае использования IPv4-адресации сетевых узлов в качестве указателя на экземпляр
						структуры данных sockaddr системному вызову bind передается указатель на экземпляр структуры данных sockaddr\_in.
						Указатель на экземпляр структуры данных sockaddr\_in явно приводится к указателю на экземпляр структуры данных sockaddr.

						Указываемый сетевой адрес суть есть IPv4-адрес сетевого интерфейса, указанный порт на котором будет прослушиваться процессом.
						В случае, если необходимо занять один и тот же порт на всех
						сетевых интерфейсах вычислительной системы, в качестве адреса целевого сетевого интерфейса указывается 0;

					\item Размер в байтах описателя адреса целевого сетевого интерфейса.

					В данном случае в качестве значения данного параметра передается\\sizeof(struct sockaddr\_in).

				\end{enumerate}

			Системный вызов bind возвращает 0 в случае успешной привязки сокета к порту и -1 в случае неудачного завершения означенной операции.

			Библиотека GLIBC предоставляет обертку для данного системного вызова, для использования которой необходимо включить в файл исходного кода программы
			заголовочные файлы <sys/types.h> и <sys/socket.h>;

		\item Перевод сокета в режим прослушивания порта.

			Перевод сокета в режим прослушивания порта осуществляется с помощью системного вызова listen, имеющего следующие параметры:

				\begin{enumerate}

					\item Номер дескриптора сокета в таблице файловых дескрипторов процесса;

					\item Максимальный размер очереди запросов на установ соединения.

						Очередной запрос на установ соединения с процессом - сервером помещается в конец очереди запросов и находится в данной очереди до тех пор,
						пока процесс - сервер не выполнит некоторую обработку данного запроса (например, не установит соединение с процессом - клиентом,
						поместившим запрос на подключение в очередь запросов).

						Максимальный размер описанной очереди запросов устанавливается рассматриваемым параметром системного вызова listen.
						Рекомендуется передавать в качестве данного параметра системному вызову listen положительные целые числа.

				\end{enumerate}

			Системный вызов listen возвращает 0 в случае успешного перевода сокета в режим прослушивания порта и -1 в случае неудачного завершения
			означенной операции.

			Библиотека GLIBC предоставляет обертку для данного системного вызова, для использования которой необходимо включить в файл исходного кода программы
			заголовочные файлы <sys/types.h> и <sys/socket.h>;

		\item Установ соединения с очередным процессом - клиентом.

			Для установа соединения с очередным процессом - клиентом, поместившим запрос на установление соединения в очередь таковых запросов,
			процесс - сервер может воспользоваться системным вызовом accetp, имеющим следующие параметры:

				\begin{enumerate}

					\item Номер дескриптора сокета в таблице файловых дескрипторов процесса;
					\item Указатель на описатель адреса сетевого узла.

						Данный описатель суть есть экземпляр структуры данных sockaddr\_in, в который помещается
						IP-адрес сетевого узла, на котором запущен процесс - клиент, и номер порта соответствующего
						сетевого интерфейса, через который процесс - клиент будет осуществлять передачу данных.

						Необходимо помнить, что IP-адрес и номер порта в экземпляре структуры данных sockaddr\_in
						хранятся в сетевом порядке байт. Для преобразования IP-адреса в строковое представление в
						стандартной нотации и для преобразования номера порта из сетевого порядка байт в порядок байт
						хоста необходимо воспользоваться функциями inet\_ntoa() и ntohs() соответственно. Данные функции
						были описаны ранее.

						Допускается передача значения NULL в качестве значения указателя на описатель адреса сетевого узла;

					\item Указатель на целочисленную переменную типа socklen\_t, в которой будет сохранен размер в байтах описателя адреса сетевого узла.

						В том случае, если в качестве указателя на описатель адреса сетевого узла системному вызова accept было передано значение NULL,
						в качестве данного параметра можно также передать значение NULL.

				\end{enumerate}

			Другим системным вызовом, который процесс может использовать для удовлетворения очередного запроса на подключение некоторого процесса - клиента,
			является системный вызов accept4, принимающий те же параметры, что и системный вызов accept, а также дополнительный параметр - флаги.

			В качестве флагов системному вызову accept4 можно передать 0 и тогда системный вызов accept4 будет выполняться также, как и системный вызов accept,
			а можно передать значение константы SOCK\_NONBLOCK и тогда системный вызов accept4, в отличии от системного вызова accept, выполнит неблокирующуюся
			операцию - то есть проверит состояние очереди запросов на подключение и, если запросы в ней отсутствуют, не будет ожидать поступления запросов,
			как это сделал бы системный вызов accept, а вернет управление в вызывавший процесс сразу с сообщением о своем неудачном завершении\footnote{Переменная
			errno, определенная в заголовочном файле <errno.h>, будет установлена в значение кода ошибки EWOULDBLOCK.}.

			В случае своего успешного завершения системные вызовы accept и accept4 возвращают вызвавшему их процессу номер в таблице файловых дескрипторов
			данного процесса дескриптора сокета, через который будет осуществляться	обмен с процессом - клиентом. В случае неудачного завершения системные вызовы
			accept и accept4 возвращают -1.

			Библиотека GLIBC предоставляет обертки для данных системных вызовов, для использования которых необходимо включить в файл исходного кода программы
			заголовочные файлы <sys/types.h> и <sys/socket.h>. Для использования обертки к системному вызову accept4 в файле исходного кода программы
			перед включением в означенный файл заголовочного файла <sys/socket.h> необходимо определить константу компилятора <<\_GNU\_SOURCE>> с помощью
			директивы <<\#define>> препроцессора;
			
		\item Запись данных в сокет (отправление данных процессу удаленного сетевого узла).
		
			Для пересылки данных процессу - клиенту процесс - сервер может воспользоваться системным вызовом send, принимающим следующие параметры:

			\begin{enumerate}

				\item Номер дескриптора сокета в таблице файловых дескрипторов процесса;
				\item Указатель на буфер, в который помещено содержимое поля <<Data>> отправляемого пакета;
				\item Размер в байтах поля <<Data>> отправляемого пакета (не превышает размер буфера);
				\item Флаги.

					В качестве флагов процесс может передать, кроме всего прочего, флаг \linebreak MSG\_DONTWAIT, как предписание ОС выполнить неблокирующуюся
					операцию. Неблокирующаяся операция не прерывает выполнение процесса и возвращает управление сразу же, как только запрос на ее выполнение
					был совершен процессом. Неблокирующаяся операция успешно завершается только в том случае, если ОС может выполнить ее немедленно, если же
					для выполнения операции требуется некоторое ожидание (блокировка), то операция завершается неудачно\footnote{Код ошибки - EWOULDBLOCK,
					сохраняемый в переменной errno, определенной в заголовочном файле <errno.h>.}.

					В том случае, если в качестве флагов передан 0, то выполняется блокирующаяся операция -
					то есть операция, могущая заблокировать выполнение процесса в том случае, если для ее выполнения требуется некоторое ожидание;
					
			\end{enumerate}

			Системный вызов send возвращает количество отправленных байт из буфера buf (значение типа ssize\_t, что соответствует целому знаковому числу)
			в случае своего успешного выполнения и -1 в случае неудачи.

			Библиотека GLIBC предоставляет обертку для данного системного вызова, для использования которой необходимо включить в файл исходного кода программы
			заголовочные файлы <sys/types.h> и <sys/socket.h>;

		\item Чтение данных из сокета (получение данных от процесса удаленного сетевого узла).

			Для чтения данных из сокета процесс - сервер может воспользоваться системным вызовом recv, описанным ранее при рассмотрении протокола UDP;

		\item Уничтожение сокета.

			Для уничтожения сокета процесс должен воспользоваться системным вызовом close, принимающим единственным параметром номер дескриптора
			сокета в таблице о файловых дескрипторов процесса.

			В случае уничтожения процессом - сервером сокета, по которому осуществлялся обмен с некоторым процессом - клиентом, виртуальный канал разрушается
			и обмен между процессами прекращается. В случае уничтожения процессом - сервером сокета, прослушиваемого им в ожидании подключения
			процессов - клиентов, процесс обработки запросов на подключение к процессу - серверу прекращается и процесс - сервер, фактически, прекращает
			быть сервером.
			
			Библиотека GLIBC предоставляет обертку для данного системного вызова, для использования которой необходимо включить в файл исходного кода программы
			заголовочный файл <unistd.h>.

	\end{enumerate}

	Процесс - клиент работает по следующему алгоритму:

	\begin{enumerate}

		\item Создание сокета.

			Для создания сокета необходимо использовать системный вызов socket, описанный ранее при рассмотрении протокола UDP, и принимающий,
			в случае протокола TCP, значения параметров, перечисленные при рассмотрении алгоритма работы процесса - сервера;

		\item Установ соединения с процессом - сервером.

			Для установа соединения с процессом - сервером процесс - клиент может воспользоваться системным вызовом connect, принимающим следующие параметры:

			\begin{itemize}

				\item Номер дескриптора сокета в таблице файловых дескрипторов процесса;
				\item Адрес целевого сетевого узла и номер прослушиваемого процессом - сервером порта соответствующего сетевого интерфейса целевого сетевого узла.

					Данный параметр суть есть указатель на экземпляр структуры данных sockaddr\_in, в котором передаются адрес целевого сетевого узла
					и номер прослушиваемого процессом - сервером порта соответствующего сетевого интерфейса целевого узла, записанные в сетевом порядке байт.
					Указатель на экземпляр структуры данных sockaddr\_in должен быть явно приведен к типу указателя на экземпляр структуры данных sockaddr;

				\item Размер в байтах экземпляра структуры данных sockaddr\_in, равный\\sizeof(struct sockaddr\_in).

			\end{itemize}

			Системный вызов connect производит запрос на подключение процесса - клиента к процессу - серверу и блокируется в ожидании удовлетворения
			запроса или удаления запроса из очереди запросов на подключение процесса - сервера. В случае удовлетворения запроса на подключение системный вызов
			connect возвращает 0, в противном случае системный вызов connect возвращает -1.

			Библиотека GLIBC предоставляет обертку для данного системного вызова, для использования которой необходимо включить в файл исходного кода программы
			заголовочные файлы <sys/types.h> и <sys/socket.h>;

		\item Запись данных в сокет (отправление данных процессу удаленного сетевого узла).
		
			Для пересылки данных процессу - серверу процесс - клиент может воспользоваться системным вызовом send, описанным при рассмотрении
			алгоритма работы процесса - сервера;

		\item Чтение данных из сокета (получение данных от процесса удаленного сетевого узла).

			Для чтения данных из сокета процесс - клиент может воспользоваться системным вызовом recv, описанным ранее при рассмотрении протокола UDP;

		\item Уничтожение сокета.

			Для уничтожения сокета процесс должен воспользоваться системным вызовом close, принимающим единственным параметром номер дескриптора
			сокета в таблице о файловых дескрипторов процесса.

			В случае уничтожения процессом - клиентом сокета, по которому осуществлялся обмен с процессом - сервером, виртуальный канал разрушается
			и обмен между процессами прекращается.
			
			Библиотека GLIBC предоставляет обертку для данного системного вызова, для использования которой необходимо включить в файл исходного кода программы
			заголовочный файл <unistd.h>.

	\end{enumerate}

